
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Advanced Full Fingerprinting Test</title>

<script>

/// Nav
(() => {
    'use strict';

    // ==================== ENTERPRISE CONFIGURATION ====================
    const CONFIG = {
        SESSION_TTL_MINUTES: 30,
        ROTATION_INTERVAL_MINUTES: 120,
        JITTER_PERCENTAGE: 0.1,
        DEBUG: false
    };

    // ==================== USER AGENT DATA CONFIGURATION ====================
    const USER_AGENT_DATA = {
        brands: [
            { brand: "Not/A)Brand", version: "99" },
            { brand: "Google Chrome", version: "119" },
            { brand: "Chromium", version: "119" }
        ],
        mobile: true,
        platform: "Android",
        platformVersion: "13.0.0",
        architecture: "arm",
        model: "SM-G991B",
        uaFullVersion: "119.0.6045.163"
    };

    // ==================== NAVIGATOR SPOOFING PROFILES ====================
    const NAVIGATOR_PROFILES = {
        ANDROID_CHROME: {
            userAgent: "Mozilla/5.0 (Linux; Android 13; SM-G991B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.6045.163 Mobile Safari/537.36",
            appVersion: "5.0 (Linux; Android 13; SM-G991B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.6045.163 Mobile Safari/537.36",
            platform: "Linux armv8l",
            vendor: "Google Inc.",
            vendorSub: "",
            product: "Gecko",
            productSub: "20030107",
            appName: "Netscape",
            appCodeName: "Mozilla",
            language: "en-US",
            languages: ["en-US", "en"],
            hardwareConcurrency: 8,
            deviceMemory: 8,
            maxTouchPoints: 10,
            pdfViewerEnabled: true,
            webdriver: false,
            doNotTrack: null,
            cookieEnabled: true,
            onLine: true,
            connection: {
                effectiveType: "4g",
                rtt: 100,
                downlink: 5.5,
                saveData: false
            }
        }
    };

    // ==================== STORAGE & STATE MANAGEMENT ====================
    const originsData = new Map();
    const sessionState = {
        currentProfile: null,
        lastRotation: Date.now(),
        sessionStart: Date.now()
    };

    // ==================== UTILITY FUNCTIONS ====================
    const objectDefineProperty = Object.defineProperty;
    const objectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    const objectGetPrototypeOf = Object.getPrototypeOf;
    const objectSetPrototypeOf = Object.setPrototypeOf;
    const mathRandom = Math.random;
    const mathFloor = Math.floor;

    const randomItem = arr => arr[mathFloor(mathRandom() * arr.length)];
    const addJitter = (value, percentage = CONFIG.JITTER_PERCENTAGE) => {
        const jitter = Math.abs(value) * percentage;
        return value + (mathRandom() * jitter * 2 - jitter);
    };

    const makeNativeString = (fnName = '') => `function ${fnName}() { [native code] }`;

    const patchToString = (origFn, fakeFn, name = '') => {
        try {
            objectDefineProperty(fakeFn, 'toString', {
                value: () => makeNativeString(name || (origFn && origFn.name) || ''),
                writable: false,
                enumerable: false,
                configurable: true
            });
        } catch (e) {
            if (CONFIG.DEBUG) console.warn('[Stealth] patchToString failed', e);
        }
    };

    const createDeepClone = (obj) => {
        if (obj === null || typeof obj !== 'object') return obj;
        if (obj instanceof Date) return new Date(obj);
        if (Array.isArray(obj)) return obj.map(createDeepClone);

        const cloned = {};
        Object.keys(obj).forEach(k => {
            cloned[k] = createDeepClone(obj[k]);
        });
        return cloned;
    };

    // ==================== FINGERPRINT MANAGEMENT ====================
    const generateSessionId = () => {
        return Math.random().toString(36).substring(2) + Date.now().toString(36);
    };

    const generateSessionFingerprint = () => {
        const baseProfile = createDeepClone(NAVIGATOR_PROFILES.ANDROID_CHROME);

        // Add slight variations for realism
        if (baseProfile.connection) {
            baseProfile.connection.rtt = mathFloor(addJitter(baseProfile.connection.rtt));
            baseProfile.connection.downlink = parseFloat(addJitter(baseProfile.connection.downlink).toFixed(1));
        }

        return {
            ...baseProfile,
            sessionId: generateSessionId(),
            timestamp: Date.now()
        };
    };

    const getOriginFingerprint = () => {
        const origin = (location && location.origin) ? location.origin : "null";
        const now = Date.now();

        if (!originsData.has(origin) ||
            (now - originsData.get(origin).timestamp > CONFIG.SESSION_TTL_MINUTES * 60 * 1000)) {

            const newFingerprint = generateSessionFingerprint();
            originsData.set(origin, newFingerprint);

            if (CONFIG.DEBUG) {
                console.log('[Stealth] New fingerprint generated for origin:', origin);
            }
        }

        return originsData.get(origin);
    };

    // ==================== ADVANCED PATCHING TECHNIQUES ====================
    const stealthDefine = (obj, prop, value, options = {}) => {
        try {
            const descriptor = objectGetOwnPropertyDescriptor(obj, prop);
            if (descriptor && descriptor.configurable === false) return false;

            // if value is a function, ensure its toString is patched
            if (typeof value === 'function') {
                patchToString(descriptor && descriptor.value, value, prop);
            }

            objectDefineProperty(obj, prop, {
                get: () => value,
                // no setter intentionally (read-only)
                enumerable: options.enumerable ?? false,
                configurable: options.configurable ?? true
            });

            return true;
        } catch (e) {
            if (CONFIG.DEBUG) {
                console.warn('[Stealth] Failed to define property:', prop, e);
            }
            return false;
        }
    };

    const stealthObject = (targetObj, fakeData, parentKey = '') => {
        if (!targetObj || typeof targetObj !== 'object') return;
        Object.keys(fakeData).forEach(key => {
            const fullKey = parentKey ? `${parentKey}.${key}` : key;

            try {
                const v = fakeData[key];
                if (v && typeof v === 'object' && !Array.isArray(v) && !(v instanceof Date)) {
                    // try to go deeper if targetObj[key] exists
                    if (targetObj[key] !== undefined && targetObj[key] !== null) {
                        stealthObject(targetObj[key], v, fullKey);
                    } else {
                        // create a readonly property that holds the object (best-effort)
                        stealthDefine(targetObj, key, v);
                    }
                } else {
                    stealthDefine(targetObj, key, v);
                }
            } catch (e) {
                if (CONFIG.DEBUG) {
                    console.warn('[Stealth] Failed to spoof:', fullKey, e);
                }
            }
        });
    };

    // ==================== USER AGENT DATA SPOOFING ====================
    const spoofUserAgentData = () => {
        try {
            if (!navigator.userAgentData) return;

            const userAgentDataProto = objectGetPrototypeOf(navigator.userAgentData);
            if (!userAgentDataProto) return;

            // Spoof getHighEntropyValues
            if (typeof userAgentDataProto.getHighEntropyValues === 'function') {
                const originalGetHighEntropyValues = userAgentDataProto.getHighEntropyValues;

                const fakeGetHighEntropyValues = function(hints) {
                    return Promise.resolve().then(() => {
                        const result = {};

                        if (!Array.isArray(hints)) hints = [];

                        hints.forEach(hint => {
                            switch (hint) {
                                case 'architecture':
                                    result.architecture = USER_AGENT_DATA.architecture;
                                    break;
                                case 'bitness':
                                    result.bitness = '64';
                                    break;
                                case 'model':
                                    result.model = USER_AGENT_DATA.model;
                                    break;
                                case 'platformVersion':
                                    result.platformVersion = USER_AGENT_DATA.platformVersion;
                                    break;
                                case 'uaFullVersion':
                                    result.uaFullVersion = USER_AGENT_DATA.uaFullVersion;
                                    break;
                                case 'fullVersionList':
                                    result.fullVersionList = USER_AGENT_DATA.brands.map(brand => ({
                                        brand: brand.brand,
                                        version: brand.version
                                    }));
                                    break;
                                default:
                                    // do nothing for unknown hints
                                    break;
                            }
                        });

                        return result;
                    });
                };

                patchToString(originalGetHighEntropyValues, fakeGetHighEntropyValues, 'getHighEntropyValues');
                stealthDefine(userAgentDataProto, 'getHighEntropyValues', fakeGetHighEntropyValues);
            }

            // Spoof brands/mobile/platform
            stealthDefine(userAgentDataProto, 'brands', USER_AGENT_DATA.brands);
            stealthDefine(userAgentDataProto, 'mobile', USER_AGENT_DATA.mobile);
            stealthDefine(userAgentDataProto, 'platform', USER_AGENT_DATA.platform);

            // Spoof toJSON method
            if (typeof userAgentDataProto.toJSON === 'function') {
                const originalToJSON = userAgentDataProto.toJSON;
                const fakeToJSON = function() {
                    return {
                        brands: USER_AGENT_DATA.brands,
                        mobile: USER_AGENT_DATA.mobile,
                        platform: USER_AGENT_DATA.platform
                    };
                };
                patchToString(originalToJSON, fakeToJSON, 'toJSON');
                stealthDefine(userAgentDataProto, 'toJSON', fakeToJSON);
            }
        } catch (e) {
            if (CONFIG.DEBUG) console.warn('[Stealth] spoofUserAgentData error', e);
        }
    };

    // ==================== NAVIGATOR SPOOFING ====================
    const spoofNavigator = () => {
        try {
            const fingerprint = getOriginFingerprint();
            const navigatorProto = objectGetPrototypeOf(navigator);

            if (!navigatorProto) return;

            // Spoof regular navigator properties
            stealthObject(navigatorProto, fingerprint);

            // Special handling for connection object
            if (fingerprint.connection && navigator.connection) {
                const connectionProto = objectGetPrototypeOf(navigator.connection);
                if (connectionProto) {
                    stealthObject(connectionProto, fingerprint.connection);
                }
            }

            // Patch navigator.toString()
            if (typeof navigatorProto.toString === 'function') {
                const originalToString = navigatorProto.toString;
                const fakeToString = function() {
                    return "[object Navigator]";
                };
                patchToString(originalToString, fakeToString, 'toString');
                stealthDefine(navigatorProto, 'toString', fakeToString);
            }
        } catch (e) {
            if (CONFIG.DEBUG) console.warn('[Stealth] spoofNavigator error', e);
        }
    };

    // ==================== IFRAME PROTECTION ====================
    const protectIframes = () => {
        try {
            if (!window.HTMLIFrameElement) return;

            const iframeProto = window.HTMLIFrameElement.prototype;
            const cd = objectGetOwnPropertyDescriptor(iframeProto, 'contentWindow');
            const originalContentWindowGetter = cd && cd.get;

            if (typeof originalContentWindowGetter === 'function') {
                const protectedContentWindowGetter = function() {
                    const win = originalContentWindowGetter.call(this);

                    if (win && win.navigator) {
                        try {
                            const fingerprint = getOriginFingerprint();
                            const iframeNavProto = objectGetPrototypeOf(win.navigator);

                            if (iframeNavProto) {
                                stealthObject(iframeNavProto, fingerprint);
                            }
                        } catch (e) {
                            if (CONFIG.DEBUG) {
                                console.warn('[Stealth] Failed to protect iframe:', e);
                            }
                        }
                    }

                    return win;
                };

                patchToString(originalContentWindowGetter, protectedContentWindowGetter, 'get');
                objectDefineProperty(iframeProto, 'contentWindow', {
                    get: protectedContentWindowGetter,
                    enumerable: true,
                    configurable: true
                });
            }
        } catch (e) {
            if (CONFIG.DEBUG) console.warn('[Stealth] protectIframes error', e);
        }
    };

    // ==================== DETECTION COUNTERMEASURES ====================
    const installCountermeasures = () => {
        try {
            const originalGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

            // Replace Object.getOwnPropertyDescriptor with a guarded wrapper
            objectDefineProperty(Object, 'getOwnPropertyDescriptor', {
                value: function(obj, prop) {
                    // call the original to get descriptor
                    const result = originalGetOwnPropertyDescriptor.call(Object, obj, prop);

                    try {
                        if (result && typeof result.get === 'function') {
                            const s = result.get.toString();
                            // very conservative check: if getter's toString contains our marker, return safe descriptor
                            if (s.includes('stealth') || s.includes('getHighEntropyValues') || s.includes('protectedContentWindowGetter')) {
                                // return a safe, non-getter descriptor that exposes the value
                                let val;
                                try {
                                    val = result.get.call(obj);
                                } catch (inner) {
                                    val = undefined;
                                }
                                return {
                                    value: val,
                                    writable: false,
                                    enumerable: result.enumerable,
                                    configurable: result.configurable
                                };
                            }
                        }
                    } catch (e) {
                        // swallow errors - fallback to original descriptor
                    }

                    return result;
                },
                configurable: true,
                writable: true,
                enumerable: false
            });

            if (CONFIG.DEBUG) console.log('[Stealth] Countermeasures installed.');
        } catch (e) {
            if (CONFIG.DEBUG) console.warn('[Stealth] installCountermeasures failed', e);
        }
    };

    // ==================== INITIALIZATION ====================
    const initializeStealth = () => {
        try {
            // Install countermeasures first
            installCountermeasures();

            // Apply spoofing
            spoofNavigator();
            spoofUserAgentData();
            protectIframes();

            // Freeze configuration objects to prevent tampering
            try { Object.freeze(USER_AGENT_DATA); } catch (e) {}
            try { Object.freeze(NAVIGATOR_PROFILES); } catch (e) {}
            try { Object.freeze(CONFIG); } catch (e) {}

            if (CONFIG.DEBUG) {
                console.log('[Stealth] Enterprise privacy protection initialized');
            }

        } catch (error) {
            if (CONFIG.DEBUG) {
                console.error('[Stealth] Initialization failed:', error);
            }
        }
    };

    // ==================== EXECUTION ====================
    // Wait for DOM to be ready for iframe protection
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeStealth);
    } else {
        initializeStealth();
    }

    // Re-apply protection on page navigation (SPA support)
    const originalPushState = history.pushState;
    const originalReplaceState = history.replaceState;

    history.pushState = function(...args) {
        const result = originalPushState.apply(this, args);
        setTimeout(initializeStealth, 50);
        return result;
    };

    history.replaceState = function(...args) {
        const result = originalReplaceState.apply(this, args);
        setTimeout(initializeStealth, 50);
        return result;
    };

    window.addEventListener('popstate', () => {
        setTimeout(initializeStealth, 50);
    });

})();


  /// Navi end




  
///battery
(() => {
  'use strict';

  const ENABLE_SPOOF = true;
  const BATTERY_UPDATE_INTERVAL = 5000; // ms
  const BATTERY_DRAIN_RATE = 0.0015;
  const BATTERY_CHARGE_RATE = 0.0025;

  // ------------------- Utility functions -------------------
  function redefine(obj, prop, value) {
    Object.defineProperty(obj, prop, {
      configurable: true,
      enumerable: true,
      get: () => value,
      set: () => {},
    });
  }

  // Simple deterministic hash for origin + tab
  function hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = ((hash << 5) - hash) + str.charCodeAt(i);
      hash |= 0;
    }
    return Math.abs(hash);
  }

  // Generate per-origin + per-tab seed
  const origin = location.origin;
  const tabId = Math.floor(Math.random() * 1e6);
  const seed = hashString(origin + tabId);

  function randomBetween(min, max, s) {
    const x = Math.sin(s) * 10000;
    return min + ((x - Math.floor(x)) * (max - min));
  }

  // ------------------- Create a battery instance -------------------
  function createFakeBattery() {
    // Initial per-tab, per-origin values
    let batteryState = {
      charging: randomBetween(0, 1, seed) > 0.5,
      level: parseFloat(randomBetween(0.2, 0.9, seed + 1).toFixed(2)), // 2 decimal places
      chargingTime: Infinity,
      dischargingTime: Infinity
    };

    // Create event target for event handling
    const eventTarget = new EventTarget();
    
    const batteryObject = {
      // Properties
      charging: batteryState.charging,
      level: batteryState.level,
      chargingTime: batteryState.chargingTime,
      dischargingTime: batteryState.dischargingTime,
      
      // Event handlers
      onchargingchange: null,
      onlevelchange: null,
      onchargingtimechange: null,
      ondischargingtimechange: null,
      
      // Event methods
      addEventListener: (type, listener, options) => {
        eventTarget.addEventListener(type, listener, options);
      },
      removeEventListener: (type, listener, options) => {
        eventTarget.removeEventListener(type, listener, options);
      },
      dispatchEvent: (event) => {
        return eventTarget.dispatchEvent(event);
      }
    };

    // ------------------- Update battery properties -------------------
    function updateBattery() {
      const oldLevel = batteryState.level;
      const oldCharging = batteryState.charging;

      // Randomly toggle charging occasionally
      if (Math.random() < 0.01) batteryState.charging = !batteryState.charging;

      // Gradual drift
      if (batteryState.charging) {
        batteryState.level = Math.min(1, batteryState.level + BATTERY_CHARGE_RATE * Math.random());
        batteryState.chargingTime = Math.floor((1 - batteryState.level) * 3600);
        batteryState.dischargingTime = Infinity;
      } else {
        batteryState.level = Math.max(0.01, batteryState.level - BATTERY_DRAIN_RATE * Math.random());
        batteryState.chargingTime = 0;
        batteryState.dischargingTime = Math.floor(batteryState.level * 3600);
      }
      
      // Format to 2 decimal places and ensure it's a number
      batteryState.level = parseFloat(batteryState.level.toFixed(2));

      // Update object properties
      batteryObject.charging = batteryState.charging;
      batteryObject.level = batteryState.level;
      batteryObject.chargingTime = batteryState.chargingTime;
      batteryObject.dischargingTime = batteryState.dischargingTime;

      // Fire events if changed
      if (batteryState.level !== oldLevel) {
        batteryObject.dispatchEvent(new Event('levelchange'));
        if (batteryObject.onlevelchange) batteryObject.onlevelchange(new Event('levelchange'));
      }
      
      if (batteryState.charging !== oldCharging) {
        batteryObject.dispatchEvent(new Event('chargingchange'));
        if (batteryObject.onchargingchange) batteryObject.onchargingchange(new Event('chargingchange'));
      }
      
      batteryObject.dispatchEvent(new Event('chargingtimechange'));
      batteryObject.dispatchEvent(new Event('dischargingtimechange'));
      
      if (batteryObject.onchargingtimechange) batteryObject.onchargingtimechange(new Event('chargingtimechange'));
      if (batteryObject.ondischargingtimechange) batteryObject.ondischargingtimechange(new Event('dischargingtimechange'));
    }

    setInterval(updateBattery, BATTERY_UPDATE_INTERVAL);

    // Set Symbol.toStringTag for proper object identification
    Object.defineProperty(batteryObject, Symbol.toStringTag, {
      value: 'BatteryManager',
      configurable: true
    });

    return batteryObject;
  }

  const fakeInstance = createFakeBattery();

  // ------------------- Patch navigator.getBattery -------------------
  if (ENABLE_SPOOF && navigator.getBattery) {
    const originalGetBattery = navigator.getBattery.bind(navigator);
    
    Object.defineProperty(navigator, 'getBattery', {
      configurable: true,
      enumerable: true,
      writable: true,
      value: () => Promise.resolve(fakeInstance)
    });

    // Preserve original function toString behavior
    const originalFuncStr = originalGetBattery.toString();
    const originalToString = Function.prototype.toString;
    
    Function.prototype.toString = function() {
      if (this === navigator.getBattery) {
        return originalFuncStr;
      }
      return originalToString.call(this);
    };
  }

  // For direct property access (some browsers)
  if (ENABLE_SPOOF) {
    Object.defineProperty(navigator, 'battery', {
      configurable: true,
      enumerable: true,
      get: () => fakeInstance
    });
  }

})();

///battery end








  
// Inject this script early (document_start) for best effect.
// It is intended for local testing/privacy research only.
const webglScript = document.createElement('script');
webglScript.textContent = `

(function() {
  'use strict';

  // Unique marker so we can safely recognize our wrappers
  const __MARK = '__wgl_spoof_v2__';

  // ===== Utilities =======================================================
  const cryptoObj = (typeof crypto !== 'undefined' && crypto) || (typeof msCrypto !== 'undefined' && msCrypto) || null;
  function rndInt(max) {
    if (cryptoObj && cryptoObj.getRandomValues) {
      const arr = new Uint32Array(1);
      cryptoObj.getRandomValues(arr);
      return arr[0] % max;
    }
    return Math.floor(Math.random() * max);
  }
  function rndFloat() {
    if (cryptoObj && cryptoObj.getRandomValues) {
      const arr = new Uint32Array(1);
      cryptoObj.getRandomValues(arr);
      return arr[0] / 0xFFFFFFFF;
    }
    return Math.random();
  }
  function pick(arr) { return arr[rndInt(arr.length)]; }

  // Session salt: deterministic within a tab/session but random across browser restarts
  const SESSION_SALT = (function() {
    try {
      if (typeof sessionStorage !== 'undefined') {
        const key = '__wgl_salt_v2';
        let v = sessionStorage.getItem(key);
        if (!v) {
          // Use time + crypto
          v = String((Date.now() ^ (rndInt(1<<30))) + (Math.floor(rndFloat()*100000)));
          sessionStorage.setItem(key, v);
        }
        return Number(v) || (Date.now() & 0xFFFFFF);
      }
    } catch (e) {}
    return Date.now() & 0xFFFFFF;
  })();

  // Minimal deterministic mask work that varies by session
  function maskWork() {
    // iterations vary with session salt so cost is not identical across clients
    const iterations = 30 + (SESSION_SALT % 40); // 30..69
    let x = 0.123456789;
    for (let i = 0; i < iterations; i++) {
      // cheap and JIT-friendly math — avoid heavy ops
      x = (x * 1.000001 + Math.sin(i + x)) % 1.0;
    }
    return x;
  }

  // Small helper to mark wrapped functions
  function markWrapped(fn) {
    try { Object.defineProperty(fn, __MARK, { value: true, configurable: true }); } catch(e) {}
    return fn;
  }

  // Create a native-like function wrapper (improves toString & descriptors)
  function makeNativeFunction(fn, name) {
    try { Object.defineProperty(fn, 'name', { value: String(name || ''), configurable: true }); } catch(e){}
    const nativeLikeToString = function() { return 'function ' + (name || '') + '() { [native code] }'; };
    try {
      // Flag the toString method for later detection by our toString proxy
      Object.defineProperty(fn, 'toString', { value: nativeLikeToString, configurable: true, writable: false, enumerable: false });
      Object.defineProperty(fn, Symbol.toStringTag, { value: 'Function', configurable: true });
    } catch(e){}
    markWrapped(fn);
    return fn;
  }

  // ===== Function.prototype.toString stealth =================================
  // Make native-like toString consistent for our wrapped functions while preserving original behavior
  (function patchFunctionToString() {
    try {
      const origToString = Function.prototype.toString;
      const origValueOf = Function.prototype.valueOf;
      const proxy = new Proxy(origToString, {
        apply(target, thisArg, args) {
          try {
            if (thisArg && (thisArg[__MARK] || (thisArg.toString && thisArg.toString.name === 'nativeLikeToString'))) {
              // keep a plausible native format
              const n = thisArg.name || '';
              return 'function ' + n + '() { [native code] }';
            }
          } catch (e) {}
          // fallback to original
          return Reflect.apply(target, thisArg, args);
        }
      });
      Object.defineProperty(Function.prototype, 'toString', {
        value: proxy,
        configurable: true,
        writable: true,
        enumerable: false
      });
      // valueOf should be untouched normally, but keep original if needed
      Function.prototype.valueOf = origValueOf;
    } catch(e) {}
  })();

  // ===== Performance.now / timing fuzzing ===================================
  // Add tiny session-consistent jitter + small random noise to thwart nanobenchmarks
  (function patchPerformance() {
    try {
      if (typeof performance !== 'undefined' && performance.now) {
        const origNow = performance.now.bind(performance);
        const baseShift = (SESSION_SALT % 7) * 0.0005; // tiny deterministic per-session base: 0..0.003
        const proxy = function() {
          // small deterministic + random micro-jitter
          const t = origNow();
          const jitter = baseShift + (rndFloat() - 0.5) * 0.0008; // +/- ~0.0004 ms
          return t + jitter;
        };
        try {
          Object.defineProperty(performance, 'now', { value: proxy, configurable: true, writable: true });
        } catch(e) {
          performance.now = proxy;
        }
      }
    } catch(e) {}
  })();

  // ===== Error stack cloaking (safe) ========================================
  // Filter stack frames that reference our injected script name or unique marker
  (function patchErrorStack() {
    try {
      const origPrepare = Error.prepareStackTrace;
      Error.prepareStackTrace = function(err, frames) {
        try {
          if (!frames || !frames.length) return origPrepare ? origPrepare(err, frames) : err.stack;
          const filtered = frames.filter(f => {
            try {
              const fn = (f.getFunctionName && f.getFunctionName()) || '';
              const file = (f.getFileName && f.getFileName()) || '';
              // drop frames referencing our marker or blob URLs where we injected
              if (file && file.indexOf('blob:') !== -1) return false;
              if (file && file.indexOf('__wgl_spoof') !== -1) return false;
              if (fn && String(fn).indexOf(__MARK) !== -1) return false;
              return true;
            } catch(e) { return true; }
          });
          return origPrepare ? origPrepare(err, filtered) : (err.name + ': ' + err.message + '\\n' + filtered.join('\\n'));
        } catch(e) {
          return origPrepare ? origPrepare(err, frames) : err.stack;
        }
      };
    } catch(e) {}
  })();

  // ===== Cross-context sync (bc + storage + postMessage + SharedWorker) =======
  // We attempt multiple sync channels so that values are consistent across same-origin tabs and frames.
  const SYNC_KEY_VENDOR = '__wgl_vendor_v2';
  const SYNC_KEY_RENDERER = '__wgl_renderer_v2';
  const SYNC_CHANNEL = '__wgl_broadcast_v2';
  let bc = null;

  function broadcastSet(vendor, renderer) {
    try { if (bc) bc.postMessage({ vendor, renderer }); } catch(e) {}
    try { if (typeof sessionStorage !== 'undefined') { sessionStorage.setItem(SYNC_KEY_VENDOR, vendor); sessionStorage.setItem(SYNC_KEY_RENDERER, renderer); } } catch(e) {}
    try { localStorage.setItem(SYNC_KEY_VENDOR, vendor); localStorage.setItem(SYNC_KEY_RENDERER, renderer); } catch(e){}
    // postMessage to same-origin frames
    try { window.postMessage({ __wgl_spoof_msg: 1, vendor, renderer }, '*'); } catch(e) {}
  }

  try {
    if (typeof BroadcastChannel !== 'undefined') {
      bc = new BroadcastChannel(SYNC_CHANNEL);
      bc.onmessage = (ev) => {
        try {
          const d = ev && ev.data;
          if (d && d.vendor && d.renderer) {
            applySpoof(d.vendor, d.renderer, false);
          }
        } catch(e){}
      };
    }
  } catch(e) { bc = null; }

  // listen storage events (other tabs)
  try {
    window.addEventListener('storage', function(ev) {
      try {
        if (!ev) return;
        if (ev.key === SYNC_KEY_VENDOR || ev.key === SYNC_KEY_RENDERER) {
          const v = localStorage.getItem(SYNC_KEY_VENDOR);
          const r = localStorage.getItem(SYNC_KEY_RENDERER);
          if (v && r) applySpoof(v, r, false);
        }
      } catch(e){}
    }, false);
  } catch(e) {}

  // listen postMessage
  try {
    window.addEventListener('message', function(ev) {
      try {
        const d = ev && ev.data;
        if (d && d.__wgl_spoof_msg && d.vendor && d.renderer) {
          applySpoof(d.vendor, d.renderer, false);
        }
      } catch(e){}
    }, false);
  } catch(e){}

  // SharedWorker best-effort sync (same-origin)
  let sharedWorkerPort = null;
  try {
    if (typeof SharedWorker !== 'undefined') {
      try {
        // Use double-quoted string for the Blob body so inner single-quotes are safe
        const swBlob = new Blob([\"self.addEventListener('connect', function(e) {\\n  var port = e.ports[0];\\n  port.onmessage = function(ev) {\\n    var d = ev.data;\\n    if (d && d.vendor && d.renderer) {\\n      // echo back to the sender port (best-effort)\\n      try { port.postMessage(d); } catch(e){}\\n    }\\n  };\\n});\\n\"], { type: 'text/javascript' });
        const swUrl = URL.createObjectURL(swBlob);
        const sw = new SharedWorker(swUrl);
        sharedWorkerPort = sw.port;
        if (sharedWorkerPort.start) sharedWorkerPort.start();
        sharedWorkerPort.onmessage = function(e) {
          try {
            const d = e && e.data;
            if (d && d.vendor && d.renderer) applySpoof(d.vendor, d.renderer, false);
          } catch(e){}
        };
      } catch(e){}
    }
  } catch(e){}

  // ===== Vendor/Renderer generation =======================================
  const VENDOR_LIST = ["Google Inc.","Intel Inc.","NVIDIA Corporation","AMD","Apple Inc."];
  const RENDERER_TEMPLATES = [
    "ANGLE (Qualcomm, Adreno (TM) {num})",
    "ANGLE (NVIDIA, NVIDIA GeForce {num})",
    "ANGLE (Intel, Intel(R) UHD Graphics {num})",
    "{vendor} GPU {num}",
    "ANGLE (Google, Google GPU {num})"
  ];
  function genRenderer(vendor) {
    const tpl = pick(RENDERER_TEMPLATES);
    // create a 3-digit-ish model number consistent per-session
    const num = 100 + Math.floor(((SESSION_SALT & 0xFFF) + rndInt(900)) % 900);
    return tpl.replace('{vendor}', vendor).replace('{num}', num);
  }

  // Current spoof values (populated by applySpoof)
  let spoofedVendor = null;
  let spoofedRenderer = null;

  function applySpoof(vendor, renderer, broadcast = true) {
    spoofedVendor = vendor;
    spoofedRenderer = renderer;
    try {
      Object.defineProperty(navigator, '__spoofed_webgl_vendor', { value: spoofedVendor, configurable: true });
      Object.defineProperty(navigator, '__spoofed_webgl_renderer', { value: spoofedRenderer, configurable: true });
      // also keep window debug props for local testing only
      try { Object.defineProperty(window, '__spoofed_webgl_vendor', { value: spoofedVendor, configurable: true }); } catch(e){}
      try { Object.defineProperty(window, '__spoofed_webgl_renderer', { value: spoofedRenderer, configurable: true }); } catch(e){}
    } catch(e){}
    if (broadcast) broadcastSet(vendor, renderer);
    // also apply to any already patched contexts/ prototypes immediately
    try { patchPrototype(window.WebGLRenderingContext && WebGLRenderingContext.prototype); } catch(e){}
    try { patchPrototype(window.WebGL2RenderingContext && WebGL2RenderingContext.prototype); } catch(e){}
  }

  // try reading from sessionStorage/localStorage first
  try {
    if (!spoofedVendor && typeof sessionStorage !== 'undefined') {
      const v = sessionStorage.getItem(SYNC_KEY_VENDOR);
      const r = sessionStorage.getItem(SYNC_KEY_RENDERER);
      if (v && r) applySpoof(v, r, false);
    }
  } catch(e){}
  try {
    if (!spoofedVendor && typeof localStorage !== 'undefined') {
      const v = localStorage.getItem(SYNC_KEY_VENDOR);
      const r = localStorage.getItem(SYNC_KEY_RENDERER);
      if (v && r) applySpoof(v, r, false);
    }
  } catch(e){}

  // If none present, pick and broadcast
  if (!spoofedVendor) {
    const v = pick(VENDOR_LIST);
    const r = genRenderer(v);
    applySpoof(v, r, true);
  }

  // ===== Real parameter cache and plausible perturbation ====================
  const UNMASKED_VENDOR_WEBGL = 0x9245;
  const UNMASKED_RENDERER_WEBGL = 0x9246;
  const realParameterCache = new Map();

  function tryProbeRealGL() {
    try {
      const probeCanvas = document.createElement('canvas');
      // don't add to DOM
      const realGL = probeCanvas.getContext('webgl2') || probeCanvas.getContext('webgl') || probeCanvas.getContext('experimental-webgl');
      if (!realGL) return;
      const params = [
        0x0BA2, 0x1F01, UNMASKED_VENDOR_WEBGL, UNMASKED_RENDERER_WEBGL,
        0x1F02, 0x8B8C, 0x0D33, 0x8B4A, 0x8B4B, 0x8B4C, 0x8872, 0x8B4D,
        0x8B50, 0x8DFA, 0x8D57, 0x84E8, 0x0D3A, 0x851C, 0x887F,
        0x0D3D, 0x8B56, 0x8B57, 0x8B58, 0x8B59, 0x8D56, 0x8D5A
      ];
      params.forEach(p => {
        try {
          const v = realGL.getParameter(p);
          if (v && (v instanceof Float32Array || v instanceof Int32Array || v instanceof Uint8Array || v instanceof Uint8ClampedArray)) {
            realParameterCache.set(p, new v.constructor(v));
          } else {
            realParameterCache.set(p, v);
          }
        } catch(e){}
      });
    } catch(e){}
  }
  tryProbeRealGL();

  // For numeric parameters, return plausible session-perturbed value
  function perturbNumeric(val, frac = 0.03) {
    if (typeof val !== 'number' || !isFinite(val)) return val;
    // small deterministic perturbation based on SESSION_SALT
    const base = ((SESSION_SALT % 100) / 1000) - 0.05; // -0.05 .. +0.049
    const randomTiny = (rndFloat() - 0.5) * frac; // +/- frac/2
    const factor = 1 + base + randomTiny;
    const pert = Math.max(1, Math.round(val * factor));
    return pert;
  }

  function cloneIfNeeded(val) {
    if (val == null) return val;
    if (val instanceof Float32Array || val instanceof Int32Array ||
        val instanceof Uint8Array || val instanceof Uint8ClampedArray) {
      return new val.constructor(val);
    }
    if (Array.isArray(val)) return val.slice();
    if (typeof val === 'number') return perturbNumeric(val);
    // strings / objects: return as-is (for vendor/renderer we override separately)
    try {
      // shallow clone plain object to avoid exposing internal references
      if (Object.prototype.toString.call(val) === '[object Object]') return Object.assign({}, val);
    } catch(e){}
    return val;
  }

  // ===== Make debug info extension =======================================
  function makeDebugInfoExtension() {
    const ext = {
      UNMASKED_VENDOR_WEBGL: UNMASKED_VENDOR_WEBGL,
      UNMASKED_RENDERER_WEBGL: UNMASKED_RENDERER_WEBGL,
      getParameter: makeNativeFunction(function(param) {
        // small mask
        maskWork();
        if (param === UNMASKED_VENDOR_WEBGL) return spoofedVendor;
        if (param === UNMASKED_RENDERER_WEBGL) return spoofedRenderer;
        return null;
      }, 'getParameter')
    };
    // mark toString as native-like
    try { Object.defineProperty(ext.getParameter, 'toString', { value: function() { return 'function getParameter() { [native code] }'; }, configurable: true }); } catch(e){}
    return ext;
  }

  // ===== Patch prototype-level functions =================================
  function patchPrototype(proto) {
    if (!proto || proto.__wgl_spoofed_v2) return;
    try {
      const origGP = proto.getParameter;
      const origGE = proto.getExtension;
      const origGSE = proto.getSupportedExtensions;

      if (origGP) {
        proto.getParameter = makeNativeFunction(function(param) {
          maskWork();
          try {
            if (param === this.VENDOR || param === UNMASKED_VENDOR_WEBGL) return spoofedVendor;
            if (param === this.RENDERER || param === UNMASKED_RENDERER_WEBGL) return spoofedRenderer;
            if (realParameterCache.has(param)) return cloneIfNeeded(realParameterCache.get(param));
            return origGP.call(this, param);
          } catch(e) {
            try { return origGP.call(this, param); } catch(_) { return null; }
          }
        }, 'getParameter');
      }

      if (origGE) {
        proto.getExtension = makeNativeFunction(function(name) {
          maskWork();
          if (name === 'WEBGL_debug_renderer_info') return makeDebugInfoExtension();
          return origGE.call(this, name);
        }, 'getExtension');
      }

      if (origGSE) {
        proto.getSupportedExtensions = makeNativeFunction(function() {
          maskWork();
          try {
            const exts = origGSE.call(this) || [];
            if (!exts.includes('WEBGL_debug_renderer_info')) exts.push('WEBGL_debug_renderer_info');
            return exts;
          } catch(e) {
            return ['WEBGL_debug_renderer_info'];
          }
        }, 'getSupportedExtensions');
      }

      // preserve descriptors typical of native functions
      ['getParameter','getExtension','getSupportedExtensions'].forEach(k => {
        try { if (proto[k]) Object.defineProperty(proto, k, { value: proto[k], configurable: true, enumerable: false, writable: true }); } catch(e){}
      });

      proto.__wgl_spoofed_v2 = true;
    } catch(e) {}
  }

  // ===== Patch a specific context instance =================================
  function patchContextInstance(gl) {
    if (!gl || gl.__wgl_spoofed_instance_v2) return gl;
    gl.__wgl_spoofed_instance_v2 = true;

    const origGetParameter = (typeof gl.getParameter === 'function') ? gl.getParameter.bind(gl) : function() { return null; };
    const origGetExtension = (typeof gl.getExtension === 'function') ? gl.getExtension.bind(gl) : function() { return null; };
    const origGetSupportedExtensions = (typeof gl.getSupportedExtensions === 'function') ? gl.getSupportedExtensions.bind(gl) : null;

    function wrappedGetParameter(param) {
      maskWork();
      try {
        if (param === (typeof gl.VENDOR !== 'undefined' ? gl.VENDOR : 0x0BA2) || param === UNMASKED_VENDOR_WEBGL) {
          return spoofedVendor;
        }
        if (param === (typeof gl.RENDERER !== 'undefined' ? gl.RENDERER : 0x1F01) || param === UNMASKED_RENDERER_WEBGL) {
          return spoofedRenderer;
        }
        if (realParameterCache.has(param)) return cloneIfNeeded(realParameterCache.get(param));
        return origGetParameter(param);
      } catch(e) {
        try { return origGetParameter(param); } catch(_) { return null; }
      }
    }

    function wrappedGetExtension(name) {
      maskWork();
      if (name === 'WEBGL_debug_renderer_info') return makeDebugInfoExtension();
      return origGetExtension(name);
    }

    const wrappedGetSupportedExtensions = origGetSupportedExtensions ? function() {
      maskWork();
      try {
        const exts = origGetSupportedExtensions() || [];
        if (!exts.includes('WEBGL_debug_renderer_info')) exts.push('WEBGL_debug_renderer_info');
        return exts;
      } catch(e) {
        return ['WEBGL_debug_renderer_info'];
      }
    } : null;

    try {
      gl.getParameter = makeNativeFunction(wrappedGetParameter, 'getParameter');
      gl.getExtension = makeNativeFunction(wrappedGetExtension, 'getExtension');
      if (wrappedGetSupportedExtensions) gl.getSupportedExtensions = makeNativeFunction(wrappedGetSupportedExtensions, 'getSupportedExtensions');

      // set descriptors to non-enumerable like built-ins
      ['getParameter','getExtension','getSupportedExtensions'].forEach(k => {
        try { if (gl[k]) Object.defineProperty(gl, k, { value: gl[k], configurable: true, enumerable: false, writable: true }); } catch(e){}
      });
    } catch(e) {}

    return gl;
  }

  // ===== Patch HTMLCanvasElement.prototype.getContext early ================
  (function patchCanvasGetContext() {
    try {
      const proto = HTMLCanvasElement.prototype;
      if (!proto) return;
      const orig = proto.getContext;
      if (!orig || orig.__wgl_getContext_patched_v2) return;
      const wrapped = makeNativeFunction(function(type, attrs) {
        // call original
        const ctx = orig.call(this, type, attrs);
        if (!ctx) return ctx;
        // patch if webgl-ish
        if (type === 'webgl' || type === 'experimental-webgl' || type === 'webgl2') {
          try { return patchContextInstance(ctx); } catch(e) { return ctx; }
        }
        return ctx;
      }, 'getContext');
      Object.defineProperty(proto, 'getContext', { value: wrapped, configurable: true, enumerable: false, writable: true });
      proto.getContext.__wgl_getContext_patched_v2 = true;
    } catch(e) {}
  })();

  // ===== Apply prototoype patches (if available) ===========================
  try { patchPrototype(window.WebGLRenderingContext && WebGLRenderingContext.prototype); } catch(e) {}
  try { patchPrototype(window.WebGL2RenderingContext && WebGL2RenderingContext.prototype); } catch(e) {}

  // ===== Patch existing canvases immediately (scan) =======================
  (function scanAndPatchExistingCanvases() {
    try {
      const canvases = document.getElementsByTagName ? document.getElementsByTagName('canvas') : [];
      for (let i = 0; i < canvases.length; i++) {
        try {
          const c = canvases[i];
          ['webgl','webgl2','experimental-webgl'].forEach(t => {
            try {
              const ctx = c.getContext(t);
              if (ctx) patchContextInstance(ctx);
            } catch(e){}
          });
        } catch(e){}
      }
    } catch(e){}
  })();

  // ===== MutationObserver to catch canvases added later ====================
  (function observeForCanvases() {
    try {
      const mo = new MutationObserver((mutations) => {
        for (const m of mutations) {
          try {
            if (m.addedNodes) {
              for (const n of m.addedNodes) {
                try {
                  if (!n) continue;
                  // cover both element and HTML string inserts
                  if (n.nodeType === 1 && n.tagName === 'CANVAS') {
                    ['webgl','webgl2','experimental-webgl'].forEach(t => {
                      try {
                        const ctx = n.getContext(t);
                        if (ctx) patchContextInstance(ctx);
                      } catch(e){}
                    });
                  } else if (n.querySelectorAll) {
                    const canvases = n.querySelectorAll('canvas');
                    for (const c of canvases) {
                      try {
                        ['webgl','webgl2','experimental-webgl'].forEach(t => {
                          try {
                            const ctx = c.getContext(t);
                            if (ctx) patchContextInstance(ctx);
                          } catch(e){}
                        });
                      } catch(e){}
                    }
                  }
                } catch(e){}
              }
            }
          } catch(e){}
        }
      });
      mo.observe(document, { childList: true, subtree: true });
      try { Object.defineProperty(window, '__wgl_spoof_mo', { value: mo, configurable: true }); } catch(e){}
    } catch(e){}
  })();

  // ===== Descriptor masking for enumerations (getOwnPropertyDescriptors etc.) ==
  (function maskEnumerations() {
    try {
      const origGetOwnPropertyDescriptors = Object.getOwnPropertyDescriptors;
      const origGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      const origGetOwnPropertyNames = Object.getOwnPropertyNames;
      const origReflectOwnKeys = Reflect.ownKeys;

      function sanitizeDescriptors(target, descriptors) {
        try {
          if (!descriptors || typeof descriptors !== 'object') return descriptors;
          const suspiciousTargets = [HTMLCanvasElement.prototype,
                                     (window.WebGLRenderingContext && WebGLRenderingContext.prototype),
                                     (window.WebGL2RenderingContext && WebGL2RenderingContext.prototype)];
          for (let st of suspiciousTargets) {
            if (!st) continue;
            if (target === st) {
              ['getContext','getParameter','getExtension','getSupportedExtensions'].forEach(k => {
                if (k in descriptors) {
                  descriptors[k] = descriptors[k] || {};
                  descriptors[k].enumerable = false;
                  descriptors[k].configurable = true;
                  descriptors[k].writable = true;
                  try { descriptors[k].value = target[k]; } catch(e){}
                }
              });
            }
          }
        } catch(e){}
        return descriptors;
      }

      Object.defineProperty(Object, 'getOwnPropertyDescriptors', {
        value: makeNativeFunction(function(obj) {
          try {
            const d = origGetOwnPropertyDescriptors.call(Object, obj);
            return sanitizeDescriptors(obj, d);
          } catch(e) { return origGetOwnPropertyDescriptors.call(Object, obj); }
        }, 'getOwnPropertyDescriptors'),
        configurable: true, enumerable: false, writable: true
      });

      Object.defineProperty(Object, 'getOwnPropertyDescriptor', {
        value: makeNativeFunction(function(obj, prop) {
          try {
            const d = origGetOwnPropertyDescriptor.call(Object, obj, prop);
            if (d) {
              const suspicious = [HTMLCanvasElement.prototype,
                                   (window.WebGLRenderingContext && WebGLRenderingContext.prototype),
                                   (window.WebGL2RenderingContext && WebGL2RenderingContext.prototype)];
              for (let st of suspicious) {
                if (!st) continue;
                if (obj === st && (prop === 'getContext' || prop === 'getParameter' || prop === 'getExtension' || prop === 'getSupportedExtensions')) {
                  d.enumerable = false; d.configurable = true; d.writable = true;
                  try { d.value = obj[prop]; } catch(e){}
                }
              }
            }
            return d;
          } catch(e) { return origGetOwnPropertyDescriptor.call(Object, obj, prop); }
        }, 'getOwnPropertyDescriptor'),
        configurable: true, enumerable: false, writable: true
      });

      Object.defineProperty(Object, 'getOwnPropertyNames', {
        value: makeNativeFunction(function(obj) {
          try {
            const names = origGetOwnPropertyNames.call(Object, obj);
            if (obj === HTMLCanvasElement.prototype || obj === (window.WebGLRenderingContext && WebGLRenderingContext.prototype) || obj === (window.WebGL2RenderingContext && WebGL2RenderingContext.prototype)) {
              ['getContext','getParameter','getExtension','getSupportedExtensions'].forEach(k => { if (!names.includes(k)) names.push(k); });
            }
            return names;
          } catch(e) { return origGetOwnPropertyNames.call(Object, obj); }
        }, 'getOwnPropertyNames'),
        configurable: true, enumerable: false, writable: true
      });

      Object.defineProperty(Reflect, 'ownKeys', {
        value: makeNativeFunction(function(obj) {
          try {
            const keys = origReflectOwnKeys.call(Reflect, obj);
            if (obj === HTMLCanvasElement.prototype || obj === (window.WebGLRenderingContext && WebGLRenderingContext.prototype) || obj === (window.WebGL2RenderingContext && WebGL2RenderingContext.prototype)) {
              ['getContext','getParameter','getExtension','getSupportedExtensions'].forEach(k => { if (!keys.includes(k)) keys.push(k); });
            }
            return keys;
          } catch(e) { return origReflectOwnKeys.call(Reflect, obj); }
        }, 'ownKeys'),
        configurable: true, enumerable: false, writable: true
      });

    } catch(e){}
  })();

  // ===== Navigator-level spoofing =========================================
  (function patchNavigatorAPIs() {
    try {
      // hardwareConcurrency: choose a plausible value (2,4,6,8)
      const plausibleHC = [2,4,6,8,12];
      const hc = plausibleHC[(SESSION_SALT % plausibleHC.length)];
      try {
        Object.defineProperty(navigator, 'hardwareConcurrency', { value: hc, configurable: true, enumerable: false });
      } catch(e){}

      // deviceMemory: common values 0.5,1,2,4,8
      const plausibleDM = [0.5,1,2,4,8];
      const dm = plausibleDM[(SESSION_SALT % plausibleDM.length)];
      try {
        Object.defineProperty(navigator, 'deviceMemory', { value: dm, configurable: true, enumerable: false });
      } catch(e){}

      // navigator.gpu (WebGPU) : present a safe stub if missing
      if (!('gpu' in navigator)) {
        try {
          const fakeGPU = { 
            // minimal plausible API surface
            getAdapter: makeNativeFunction(function() { return Promise.resolve(null); }, 'getAdapter')
          };
          try { Object.defineProperty(navigator, 'gpu', { value: fakeGPU, configurable: true }); } catch(e){}
        } catch(e){}
      } else {
        // if real exists, don't modify, but could optionally wrap (risky)
      }
    } catch(e){}
  })();

  // ===== Finally: ensure existing contexts are patched once more ==============
  (function finalScanContexts() {
    try {
      const canvases = document.getElementsByTagName ? document.getElementsByTagName('canvas') : [];
      for (let i = 0; i < canvases.length; i++) {
        try {
          const c = canvases[i];
          ['webgl','webgl2','experimental-webgl'].forEach(t => {
            try {
              const ctx = c.getContext(t);
              if (ctx) patchContextInstance(ctx);
            } catch(e){}
          });
        } catch(e){}
      }
    } catch(e){}
  })();

  // ===== End of script - expose small debug API for local testing only =====
  try {
    Object.defineProperty(window, '__wgl_spoof_info_v2', { value: { vendor: spoofedVendor, renderer: spoofedRenderer }, configurable: true });
    // small function to change spoof values during testing
    try {
      Object.defineProperty(window, '__wgl_set_spoof_v2', { value: function(vendor, renderer) { applySpoof(vendor, renderer, true); }, configurable: true });
    } catch(e){}
  } catch(e) {}

})(); `;

document.documentElement.appendChild(webglScript);
// remove the injected script element after it has run (keeps DOM clean)
try { webglScript.remove(); } catch (e) {}



  
</script>

  
<style>
  body {
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    background: #f5f7fa;
    color: #333;
    margin: 0;
    padding: 20px;
    line-height: 1.5;
  }
  h1 {
    text-align: center;
    margin-bottom: 1em;
    color: #005a87;
  }
  #results {
    max-width: 900px;
    margin: 0 auto;
    background: #fff;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 12px rgba(0,0,0,0.1);
  }
  pre {
    background: #222;
    color: #0f0;
    padding: 10px;
    border-radius: 6px;
    overflow-x: auto;
  }
  .section {
    margin-bottom: 1.5em;
  }
  .section h2 {
    border-bottom: 2px solid #005a87;
    padding-bottom: 0.3em;
    margin-bottom: 0.7em;
    color: #0073b1;
  }
  table {
    border-collapse: collapse;
    width: 100%;
  }
  th, td {
    text-align: left;
    padding: 8px 10px;
    border-bottom: 1px solid #ddd;
  }
  th {
    background-color: #e2f0fb;
  }
  .loading {
    text-align: center;
    font-style: italic;
    color: #777;
    margin-top: 2em;
  }
  .error {
    color: #c00;
    font-weight: bold;
  }
  code {
    background: #eee;
    padding: 2px 4px;
    border-radius: 3px;
  }
</style>
</head>
<body>

<h1>Advanced Full Fingerprinting Test</h1>
<div id="results">
  <div class="loading">Running tests, please wait...</div>
</div>

<script>
window.onload = function() {

setTimeout(function() {

(async function fingerprintingTest() {


  const resultsDiv = document.getElementById('results');

  function safeCall(fn, fallback = null) {
    try {
      return fn();
    } catch {
      return fallback;
    }
  }

  async function hashString(str) {
    const msgUint8 = new TextEncoder().encode(str);
    const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  }

  // Canvas fingerprint
  async function testCanvas() {
    try {
      const canvas = document.createElement('canvas');
      canvas.width = 200;
      canvas.height = 50;
      const ctx = canvas.getContext('2d');
      if (!ctx) return { supported: false };

      ctx.textBaseline = "top";
      ctx.font = "16px 'Arial'";
      ctx.fillStyle = "#f60";
      ctx.fillRect(125, 1, 62, 20);
      ctx.fillStyle = "#069";
      ctx.fillText("Fingerprint test", 2, 15);
      ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
      ctx.fillText("Fingerprint test", 4, 17);

      const dataUrl = canvas.toDataURL();
      return { supported: true, dataUrlHash: await hashString(dataUrl), dataUrl };
    } catch (e) {
      return { supported: false, error: e.message };
    }
  }

  // WebGL info
  function testWebGL() {
    try {
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      if (!gl) return { supported: false };

      const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
      const vendor = debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : null;
      const renderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : null;
      return { supported: true, vendor, renderer };
    } catch (e) {
      return { supported: false, error: e.message };
    }
  }

  function testWebGL2() {
    try {
      const canvas = document.createElement('canvas');
      const gl2 = canvas.getContext('webgl2');
      return { supported: !!gl2 };
    } catch {
      return { supported: false };
    }
  }

  // WebRTC support check
  function testWebRTC() {
    try {
      if (!window.RTCPeerConnection) return { supported: false };
      const pc = new RTCPeerConnection({ iceServers: [] });
      return { supported: true };
    } catch (e) {
      return { supported: false, error: e.message };
    }
  }

  // Battery API
  async function testBattery() {
    if (!navigator.getBattery) return { supported: false };
    try {
      const battery = await navigator.getBattery();
      return {
        supported: true,
        charging: battery.charging,
        level: battery.level,
        chargingTime: battery.chargingTime,
        dischargingTime: battery.dischargingTime,
      };
    } catch (e) {
      return { supported: false, error: e.message };
    }
  }

  // Sensors detection
  function testSensors() {
    let accelerometerSupported = false;
    let gyroscopeSupported = false;
    let magnetometerSupported = false;

    try { accelerometerSupported = 'Accelerometer' in window; } catch {}
    try { gyroscopeSupported = 'Gyroscope' in window; } catch {}
    try { magnetometerSupported = 'Magnetometer' in window; } catch {}

    return { accelerometerSupported, gyroscopeSupported, magnetometerSupported };
  }

  // AudioContext detection (basic)
  function testAudioContext() {
    try {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      if (!AudioContext) return { supported: false };
      const ctx = new AudioContext();
      ctx.close();
      return { supported: true };
    } catch (e) {
      return { supported: false, error: e.message };
    }
  }

  // Fonts detection (basic)
  function testFonts() {
    try {
      const baseFonts = ['monospace', 'sans-serif', 'serif'];
      const testString = "mmmmmmmmmmlli";
      const testSize = '72px';

      const body = document.body;

      const defaultWidth = {};
      const defaultHeight = {};

      baseFonts.forEach(function(font) {
        const span = document.createElement("span");
        span.style.fontFamily = font;
        span.style.fontSize = testSize;
        span.style.position = "absolute";
        span.style.left = "-9999px";
        span.innerHTML = testString;
        body.appendChild(span);
        defaultWidth[font] = span.offsetWidth;
        defaultHeight[font] = span.offsetHeight;
        body.removeChild(span);
      });

      const testFont = "this-font-does-not-exist-123456";
      const detectedFonts = [];

      const span = document.createElement("span");
      span.style.fontSize = testSize;
      span.style.position = "absolute";
      span.style.left = "-9999px";
      span.innerHTML = testString;

      baseFonts.forEach(function(baseFont) {
        span.style.fontFamily = `'${testFont}',${baseFont}`;
        body.appendChild(span);
        const matched = (span.offsetWidth !== defaultWidth[baseFont]) || (span.offsetHeight !== defaultHeight[baseFont]);
        if (matched) detectedFonts.push(testFont);
        body.removeChild(span);
      });

      return { fontDetectionPossible: detectedFonts.length > 0 };
    } catch (e) {
      return { fontDetectionPossible: false, error: e.message };
    }
  }

  // Permissions API test
  async function testPermissions() {
    if (!navigator.permissions) return { supported: false };
    const permissionsToCheck = [
      'geolocation',
      'notifications',
      'push',
      'midi',
      'camera',
      'microphone',
      'background-sync',
      'ambient-light-sensor',
      'accelerometer',
      'gyroscope',
      'magnetometer',
      'clipboard-read',
      'clipboard-write',
    ];

    const results = {};
    for (const perm of permissionsToCheck) {
      try {
        const status = await navigator.permissions.query({ name: perm });
        results[perm] = status.state;
      } catch {
        results[perm] = 'not supported';
      }
    }
    return results;
  }

  // Storage API tests
  function testStorage() {
    let localStorageAvailable = false;
    let sessionStorageAvailable = false;
    try {
      localStorage.setItem('test', 'test');
      localStorage.removeItem('test');
      localStorageAvailable = true;
    } catch {}
    try {
      sessionStorage.setItem('test', 'test');
      sessionStorage.removeItem('test');
      sessionStorageAvailable = true;
    } catch {}

    return { localStorageAvailable, sessionStorageAvailable };
  }

  // IndexedDB support
  function testIndexedDB() {
    return ('indexedDB' in window);
  }

  // Plugins info
  function testPlugins() {
    try {
      if (!navigator.plugins) return null;
      const plugins = [];
      for (let i = 0; i < navigator.plugins.length; i++) {
        const p = navigator.plugins[i];
        plugins.push(`${p.name} (version: ${p.version || 'N/A'})`);
      }
      return plugins;
    } catch {
      return null;
    }
  }

  // Touch support
  function testTouchSupport() {
    const maxTouchPoints = navigator.maxTouchPoints || 0;
    const touchEvent = 'ontouchstart' in window;
    const touchSupported = maxTouchPoints > 0 || touchEvent;
    return { maxTouchPoints, touchSupported };
  }

  // Device memory
  function testDeviceMemory() {
    return navigator.deviceMemory || 'Not supported';
  }

  // Hardware concurrency (number of CPU cores)
  function testHardwareConcurrency() {
    return navigator.hardwareConcurrency || 'Not supported';
  }

  // Timezone info
  function testTimezone() {
    try {
      return Intl.DateTimeFormat().resolvedOptions().timeZone || 'Unavailable';
    } catch {
      return 'Unavailable';
    }
  }

  // Screen info
  function testScreen() {
    return {
      width: screen.width,
      height: screen.height,
      availWidth: screen.availWidth,
      availHeight: screen.availHeight,
      colorDepth: screen.colorDepth,
      pixelDepth: screen.pixelDepth,
    };
  }

  // Language info
  function testLanguage() {
    return {
      language: navigator.language,
      languages: navigator.languages,
      userLanguage: navigator.userLanguage || null, // IE only
      browserLanguage: navigator.browserLanguage || null, // IE only
      systemLanguage: navigator.systemLanguage || null, // IE only
    };
  }

  // Cookies enabled
  function testCookies() {
    return navigator.cookieEnabled;
  }

  // Do Not Track
  function testDoNotTrack() {
    return navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack || 'Unavailable';
  }

  // User Agent
  function testUserAgent() {
    return navigator.userAgent || 'Unavailable';
  }

  // Referrer
  function testReferrer() {
    return document.referrer || 'None';
  }

  // Build and display results
  async function runTests() {
    const results = {};

    // Basic Info
    results.userAgent = testUserAgent();
    results.languages = testLanguage();
    results.platform = navigator.platform || 'Unavailable';
    results.doNotTrack = testDoNotTrack();
    results.cookiesEnabled = testCookies();

    // Screen Info
    results.screen = testScreen();

    // Timezone
    results.timezone = testTimezone();

    // Hardware
    results.deviceMemory = testDeviceMemory();
    results.hardwareConcurrency = testHardwareConcurrency();

    // Storage
    results.storage = testStorage();
    results.indexedDB = testIndexedDB();

    // Plugins
    results.plugins = testPlugins();

    // Touch
    results.touch = testTouchSupport();

    // Canvas
    results.canvas = await testCanvas();

    // WebGL/WebGL2
    results.webgl = testWebGL();
    results.webgl2 = testWebGL2();

    // WebRTC
    results.webrtc = testWebRTC();

    // Battery API
    results.battery = await testBattery();

    // Sensors
    results.sensors = testSensors();

    // AudioContext
    results.audioContext = testAudioContext();

    // Fonts
    results.fonts = testFonts();

    // Permissions API
    results.permissions = await testPermissions();

    // Referrer
    results.referrer = testReferrer();

    return results;
  }

  function createTable(data) {
    const table = document.createElement('table');
    for (const [key, value] of Object.entries(data)) {
      const row = document.createElement('tr');
      const cellKey = document.createElement('th');
      cellKey.textContent = key;
      const cellValue = document.createElement('td');
      if (value === null) {
        cellValue.textContent = 'N/A';
      } else if (Array.isArray(value)) {
        if (value.length === 0) {
          cellValue.textContent = 'None';
        } else {
          cellValue.innerHTML = '<ul>' + value.map(item => `<li>${item}</li>`).join('') + '</ul>';
        }
      } else if (typeof value === 'object') {
        cellValue.textContent = JSON.stringify(value, null, 2);
      } else {
        cellValue.textContent = String(value);
      }
      row.appendChild(cellKey);
      row.appendChild(cellValue);
      table.appendChild(row);
    }
    return table;
  }

  function renderResults(results) {
    resultsDiv.innerHTML = '';

    // Basic info
    const basicInfo = document.createElement('div');
    basicInfo.className = 'section';
    basicInfo.innerHTML = `<h2>Basic Browser & System Info</h2>`;
    basicInfo.appendChild(createTable({
      'User Agent': results.userAgent,
      'Platform': results.platform,
      'Do Not Track': results.doNotTrack,
      'Cookies Enabled': results.cookiesEnabled,
      'Referrer': results.referrer,
      'Languages': results.languages.language + (results.languages.languages ? ` (All: ${results.languages.languages.join(', ')})` : ''),
    }));
    resultsDiv.appendChild(basicInfo);

    // Screen info
    const screenSection = document.createElement('div');
    screenSection.className = 'section';
    screenSection.innerHTML = `<h2>Screen Information</h2>`;
    screenSection.appendChild(createTable(results.screen));
    resultsDiv.appendChild(screenSection);

    // Timezone
    const timezoneSection = document.createElement('div');
    timezoneSection.className = 'section';
    timezoneSection.innerHTML = `<h2>Timezone</h2><p>${results.timezone}</p>`;
    resultsDiv.appendChild(timezoneSection);

    // Hardware
    const hardwareSection = document.createElement('div');
    hardwareSection.className = 'section';
    hardwareSection.innerHTML = `<h2>Hardware Info</h2>`;
    hardwareSection.appendChild(createTable({
      'Device Memory (GB)': results.deviceMemory,
      'Hardware Concurrency (CPU cores)': results.hardwareConcurrency,
    }));
    resultsDiv.appendChild(hardwareSection);

    // Storage
    const storageSection = document.createElement('div');
    storageSection.className = 'section';
    storageSection.innerHTML = `<h2>Storage Support</h2>`;
    storageSection.appendChild(createTable({
      LocalStorage: results.storage.localStorageAvailable,
      SessionStorage: results.storage.sessionStorageAvailable,
      IndexedDB: results.indexedDB,
    }));
    resultsDiv.appendChild(storageSection);

    // Plugins
    const pluginsSection = document.createElement('div');
    pluginsSection.className = 'section';
    pluginsSection.innerHTML = `<h2>Plugins</h2>`;
    if (results.plugins === null) {
      pluginsSection.innerHTML += `<p>Plugin enumeration blocked or not supported</p>`;
    } else if (results.plugins.length === 0) {
      pluginsSection.innerHTML += `<p>No plugins detected</p>`;
    } else {
      pluginsSection.appendChild(createTable({ Plugins: results.plugins }));
    }
    resultsDiv.appendChild(pluginsSection);

    // Touch support
    const touchSection = document.createElement('div');
    touchSection.className = 'section';
    touchSection.innerHTML = `<h2>Touch Support</h2>`;
    touchSection.appendChild(createTable(results.touch));
    resultsDiv.appendChild(touchSection);

    // Canvas fingerprint
    const canvasSection = document.createElement('div');
    canvasSection.className = 'section';
    canvasSection.innerHTML = `<h2>Canvas Fingerprint</h2>`;
    if (results.canvas.supported) {
      canvasSection.innerHTML += `<p>Canvas fingerprint hash: <code>${results.canvas.dataUrlHash}</code></p>`;
      canvasSection.innerHTML += `<img src="${results.canvas.dataUrl}" alt="Canvas output" style="border:1px solid #ccc; max-width: 100%;">`;
    } else {
      canvasSection.innerHTML += `<p class="error">Canvas not supported or blocked</p>`;
      if (results.canvas.error) canvasSection.innerHTML += `<p class="error">Error: ${results.canvas.error}</p>`;
    }
    resultsDiv.appendChild(canvasSection);

    // WebGL info
    const webglSection = document.createElement('div');
    webglSection.className = 'section';
    webglSection.innerHTML = `<h2>WebGL</h2>`;
    if (results.webgl.supported) {
      webglSection.appendChild(createTable({
        Vendor: results.webgl.vendor || 'Unavailable',
        Renderer: results.webgl.renderer || 'Unavailable',
      }));
    } else {
      webglSection.innerHTML += `<p class="error">WebGL not supported or blocked.</p>`;
      if (results.webgl.error) webglSection.innerHTML += `<p class="error">Error: ${results.webgl.error}</p>`;
    }
    resultsDiv.appendChild(webglSection);

    // WebGL2
    const webgl2Section = document.createElement('div');
    webgl2Section.className = 'section';
    webgl2Section.innerHTML = `<h2>WebGL2</h2>`;
    webgl2Section.innerHTML += `<p>${results.webgl2.supported ? 'Supported' : 'Not supported or blocked'}</p>`;
    resultsDiv.appendChild(webgl2Section);

    // WebRTC
    const webrtcSection = document.createElement('div');
    webrtcSection.className = 'section';
    webrtcSection.innerHTML = `<h2>WebRTC</h2>`;
    webrtcSection.innerHTML += `<p>${results.webrtc.supported ? 'Supported' : 'Not supported or blocked'}</p>`;
    resultsDiv.appendChild(webrtcSection);

    // Battery
    const batterySection = document.createElement('div');
    batterySection.className = 'section';
    batterySection.innerHTML = `<h2>Battery API</h2>`;
    if (results.battery.supported) {
      batterySection.appendChild(createTable({
        Charging: results.battery.charging,
        Level: results.battery.level,
        ChargingTime: results.battery.chargingTime,
        DischargingTime: results.battery.dischargingTime,
      }));
    } else {
      batterySection.innerHTML += `<p>Battery API not supported or blocked.</p>`;
      if (results.battery.error) batterySection.innerHTML += `<p class="error">Error: ${results.battery.error}</p>`;
    }
    resultsDiv.appendChild(batterySection);

    // Sensors
    const sensorsSection = document.createElement('div');
    sensorsSection.className = 'section';
    sensorsSection.innerHTML = `<h2>Sensors Support</h2>`;
    sensorsSection.appendChild(createTable({
      Accelerometer: results.sensors.accelerometerSupported,
      Gyroscope: results.sensors.gyroscopeSupported,
      Magnetometer: results.sensors.magnetometerSupported,
    }));
    resultsDiv.appendChild(sensorsSection);

    // AudioContext
    const audioSection = document.createElement('div');
    audioSection.className = 'section';
    audioSection.innerHTML = `<h2>Audio Context</h2>`;
    if (results.audioContext.supported) {
      audioSection.innerHTML += `<p>Supported</p>`;
    } else {
      audioSection.innerHTML += `<p class="error">Not supported or blocked</p>`;
      if (results.audioContext.error) audioSection.innerHTML += `<p class="error">Error: ${results.audioContext.error}</p>`;
    }
    resultsDiv.appendChild(audioSection);

    // Fonts
    const fontsSection = document.createElement('div');
    fontsSection.className = 'section';
    fontsSection.innerHTML = `<h2>Fonts Detection</h2>`;
    if (results.fonts.fontDetectionPossible) {
      fontsSection.innerHTML += `<p>Font detection possible</p>`;
    } else {
      fontsSection.innerHTML += `<p>Font detection not possible or blocked</p>`;
      if (results.fonts.error) fontsSection.innerHTML += `<p class="error">Error: ${results.fonts.error}</p>`;
    }
    resultsDiv.appendChild(fontsSection);

    // Permissions
    const permSection = document.createElement('div');
    permSection.className = 'section';
    permSection.innerHTML = `<h2>Permissions API</h2>`;
    if (results.permissions.supported === false) {
      permSection.innerHTML += `<p>Permissions API not supported</p>`;
    } else {
      permSection.appendChild(createTable(results.permissions));
    }
    resultsDiv.appendChild(permSection);
  }

  try {
    const results = await runTests();
    renderResults(results);
  } catch (e) {
    resultsDiv.innerHTML = `<p class="error">Error running tests: ${e.message}</p>`;
  }
})();


}, 5000);

}
</script>

</body>
</html>
