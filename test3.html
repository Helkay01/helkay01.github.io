<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Advanced Fingerprint & Spoof Detection</title>

<style>
body {
    background:#0b0d12;
    color:#e6e6e6;
    font-family:system-ui, sans-serif;
    margin:0;
    padding:20px;
}
h1 { text-align:center; }
.section {
    margin-top:25px;
    padding:15px;
    border-radius:10px;
    background:#141826;
    box-shadow:0 0 0 1px #2a3042;
}
.section h2 {
    margin-top:0;
    border-bottom:1px solid #2a3042;
    padding-bottom:6px;
}
.grid {
    display:grid;
    grid-template-columns: repeat(3, 1fr);
    gap:15px;
}
.card {
    background:#0f1320;
    border-radius:8px;
    padding:10px;
    font-size:13px;
}
.row {
    display:flex;
    justify-content:space-between;
    border-bottom:1px dashed #2a3042;
    padding:4px 0;
}
.row:last-child { border-bottom:none; }
.bad { color:#ff5f5f; font-weight:bold; }
.good { color:#6bff95; }
.warn { color:#ffd966; }
small { color:#999; }
</style>
</head>

<body>
<h1>Advanced Fingerprint & Spoof Detection</h1>
<small>Red = mismatch â†’ likely JS-only spoofing</small>

<div class="section">
<h2>Fingerprint Comparison</h2>
<div class="grid" id="grid"></div>
</div>

<script>
/* ------------------ UTILITIES ------------------ */

async function hash(str) {
    const buf = new TextEncoder().encode(str);
    const digest = await crypto.subtle.digest("SHA-256", buf);
    return [...new Uint8Array(digest)].map(b=>b.toString(16).padStart(2,"0")).join("");
}

function getCanvasFP() {
    const c = document.createElement("canvas");
    c.width = 300; c.height = 80;
    const x = c.getContext("2d");
    x.textBaseline="top";
    x.font="16px Arial";
    x.fillStyle="#f60";
    x.fillRect(0,0,300,80);
    x.fillStyle="#069";
    x.fillText("Fingerprint Test ðŸ§¬", 10, 10);
    return c.toDataURL();
}

function getWebGLFP(canvas) {
    const gl = canvas.getContext("webgl");
    if (!gl) return {vendor:"none", renderer:"none", params:"none"};
    const dbg = gl.getExtension("WEBGL_debug_renderer_info");
    const vendor = dbg ? gl.getParameter(dbg.UNMASKED_VENDOR_WEBGL) : "masked";
    const renderer = dbg ? gl.getParameter(dbg.UNMASKED_RENDERER_WEBGL) : "masked";

    const params = [
        gl.getParameter(gl.MAX_TEXTURE_SIZE),
        gl.getParameter(gl.MAX_RENDERBUFFER_SIZE),
        gl.getParameter(gl.MAX_VERTEX_ATTRIBS)
    ].join(",");

    return {vendor, renderer, params};
}

async function getAudioFP() {
    try {
        const ctx = new AudioContext();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(0);
        const fp = gain.gain.value.toString();
        osc.stop();
        ctx.close();
        return fp;
    } catch {
        return "blocked";
    }
}

/* ------------------ MAIN ENV ------------------ */

async function collectMain() {
    const canvas = document.createElement("canvas");
    const gl = getWebGLFP(canvas);

    return {
        env: "Main",
        ua: navigator.userAgent,
        uach: navigator.userAgentData?.platform || "n/a",
        platform: navigator.platform,
        lang: navigator.languages?.join(","),
        mem: navigator.deviceMemory ?? "undef",
        cores: navigator.hardwareConcurrency,
        touch: navigator.maxTouchPoints,
        webdriver: navigator.webdriver,
        tz: Intl.DateTimeFormat().resolvedOptions().timeZone,
        canvas: await hash(getCanvasFP()),
        webgl: await hash(gl.vendor + gl.renderer + gl.params),
        audio: await hash(await getAudioFP())
    };
}

/* ------------------ WORKER ENV ------------------ */

const workerCode = `
self.onmessage = async () => {
    function hash(str) {
        const buf = new TextEncoder().encode(str);
        return crypto.subtle.digest("SHA-256", buf)
        .then(d => [...new Uint8Array(d)].map(b=>b.toString(16).padStart(2,"0")).join(""));
    }

    let webgl = "none";
    try {
        const c = new OffscreenCanvas(64,64);
        const gl = c.getContext("webgl");
        if (gl) {
            const dbg = gl.getExtension("WEBGL_debug_renderer_info");
            webgl = dbg ?
              gl.getParameter(dbg.UNMASKED_VENDOR_WEBGL) +
              gl.getParameter(dbg.UNMASKED_RENDERER_WEBGL) :
              "masked";
        }
    } catch {}

    self.postMessage({
        env:"Worker",
        ua:navigator.userAgent,
        uach:navigator.userAgentData?.platform || "n/a",
        platform:navigator.platform,
        lang:navigator.languages?.join(","),
        mem:navigator.deviceMemory ?? "undef",
        cores:navigator.hardwareConcurrency,
        touch:navigator.maxTouchPoints,
        webdriver:navigator.webdriver,
        tz:Intl.DateTimeFormat().resolvedOptions().timeZone,
        canvas:"no-dom",
        webgl: await hash(webgl),
        audio:"no-audio"
    });
};
`;

const worker = new Worker(URL.createObjectURL(new Blob([workerCode])));
const workerData = new Promise(r => worker.onmessage = e => r(e.data));
worker.postMessage({});

/* ------------------ SERVICE WORKER ------------------ */

async function collectSW() {
    if (!("serviceWorker" in navigator)) return null;

    const swCode = `
self.addEventListener("message", async e => {
    function hash(str) {
        const buf = new TextEncoder().encode(str);
        return crypto.subtle.digest("SHA-256", buf)
        .then(d => [...new Uint8Array(d)].map(b=>b.toString(16).padStart(2,"0")).join(""));
    }

    let webgl="none";
    try {
        const c=new OffscreenCanvas(64,64);
        const gl=c.getContext("webgl");
        if(gl){
            const dbg=gl.getExtension("WEBGL_debug_renderer_info");
            webgl=dbg?gl.getParameter(dbg.UNMASKED_VENDOR_WEBGL):"masked";
        }
    }catch{}

    e.source.postMessage({
        env:"ServiceWorker",
        ua:navigator.userAgent,
        uach:navigator.userAgentData?.platform || "n/a",
        platform:navigator.platform,
        lang:navigator.languages?.join(","),
        mem:navigator.deviceMemory ?? "undef",
        cores:navigator.hardwareConcurrency,
        touch:navigator.maxTouchPoints,
        webdriver:navigator.webdriver,
        tz:Intl.DateTimeFormat().resolvedOptions().timeZone,
        canvas:"no-dom",
        webgl: await hash(webgl),
        audio:"no-audio"
    });
});
`;

    const blob = new Blob([swCode], {type:"text/javascript"});
    const url = URL.createObjectURL(blob);
    const reg = await navigator.serviceWorker.register(url);
    await navigator.serviceWorker.ready;

    return new Promise(r => {
        navigator.serviceWorker.onmessage = e => r(e.data);
        navigator.serviceWorker.controller?.postMessage({});
    });
}

/* ------------------ RENDER ------------------ */

function render(all) {
    const grid = document.getElementById("grid");
    const keys = Object.keys(all[0]).filter(k=>k!=="env");

    all.forEach(env => {
        const c = document.createElement("div");
        c.className="card";
        c.innerHTML=`<b>${env.env}</b>`;
        keys.forEach(k=>{
            const base = all[0][k];
            const same = String(env[k]) === String(base);
            c.innerHTML += `
                <div class="row">
                    <span>${k}</span>
                    <span class="${same?"good":"bad"}">${env[k]}</span>
                </div>`;
        });
        grid.appendChild(c);
    });
}

/* ------------------ RUN ------------------ */

(async ()=>{
    const main = await collectMain();
    const workerEnv = await workerData;
    const sw = await collectSW();

    const all = [main, workerEnv];
    if (sw) all.push(sw);

    render(all);
})();
</script>

</body>
</html>
